{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Python \u00b6 Sobre Python \u00b6 Python \u00e9 uma linguagem de programa\u00e7\u00e3o de prop\u00f3sito geral e se torna um poderoso ambiente para computa\u00e7\u00e3o cient\u00edfica quando algumas bibliotecas como numpy, matplotlib, scipy e etc auxiliam. No ano de 2020, IEEE Computer Society publicou as linguagens est\u00e3o emergentes e Python est\u00e1 em primeiro lugar na lista. A linguagem Python foi criada em 1991 por um holand\u00eas chamado Guido Van Rossumem. Python foi um nome provis\u00f3rio do projeto em que Guido estava envolvido, e este nome vem da s\u00e9rie \"Monty Python's Flying Circus\", da qual Guido era extremamente f\u00e3. O intuito do Guido era ter uma linguagem poderosa para desenvolver e administrar sistemas, por\u00e9m que fosse simples e de f\u00e1cil entendimento. Em outras linguagens, \u00e9 muito comum o uso intensivo de marca\u00e7\u00f5es (;, .), marcadores (chaves, colchetes) e palavras espec\u00edficas como begin e end. E Python tem legibilidade como uma das principais caracter\u00edsticas, onde o uso destes recursos \u00e9 reduzido, resultando em uma linguagem limpa e de leitura mais f\u00e1cil. Python \u00e9 uma linguagem de alto n\u00edvel e dinamicamente tipada, \u00e9 bastante semelhante a um pseudoc\u00f3digo, onde se pode expressar ideias complexas em poucas linhas de c\u00f3digo. Download \u00b6 O interpretador para Python est\u00e1 dispon\u00edvel para os sistemas operacionais Microsoft Windows, macOS, e Linux.","title":"Home"},{"location":"index.html#python","text":"","title":"Python"},{"location":"index.html#sobre-python","text":"Python \u00e9 uma linguagem de programa\u00e7\u00e3o de prop\u00f3sito geral e se torna um poderoso ambiente para computa\u00e7\u00e3o cient\u00edfica quando algumas bibliotecas como numpy, matplotlib, scipy e etc auxiliam. No ano de 2020, IEEE Computer Society publicou as linguagens est\u00e3o emergentes e Python est\u00e1 em primeiro lugar na lista. A linguagem Python foi criada em 1991 por um holand\u00eas chamado Guido Van Rossumem. Python foi um nome provis\u00f3rio do projeto em que Guido estava envolvido, e este nome vem da s\u00e9rie \"Monty Python's Flying Circus\", da qual Guido era extremamente f\u00e3. O intuito do Guido era ter uma linguagem poderosa para desenvolver e administrar sistemas, por\u00e9m que fosse simples e de f\u00e1cil entendimento. Em outras linguagens, \u00e9 muito comum o uso intensivo de marca\u00e7\u00f5es (;, .), marcadores (chaves, colchetes) e palavras espec\u00edficas como begin e end. E Python tem legibilidade como uma das principais caracter\u00edsticas, onde o uso destes recursos \u00e9 reduzido, resultando em uma linguagem limpa e de leitura mais f\u00e1cil. Python \u00e9 uma linguagem de alto n\u00edvel e dinamicamente tipada, \u00e9 bastante semelhante a um pseudoc\u00f3digo, onde se pode expressar ideias complexas em poucas linhas de c\u00f3digo.","title":"Sobre Python"},{"location":"index.html#download","text":"O interpretador para Python est\u00e1 dispon\u00edvel para os sistemas operacionais Microsoft Windows, macOS, e Linux.","title":"Download"},{"location":"Basic/intro.html","text":"","title":"Introdu\u00e7\u00e3o"},{"location":"Basic/CollectionsTypes/array.html","text":"Agora vamos apresentar a estrutura de dados chamada lista, este tipo de estrutura permite armazenar valor de um mesmo tipo de maneira ordenada, no geral cole\u00e7\u00f5es de dados s\u00e3o estruturas muito tranquilas de trabalhar em Python, a linguagem implementa muitas fun\u00e7\u00f5es nativas e tem uma sintaxe bem vers\u00e1til para trabalhar com listas. Em linguagens de tipo est\u00e1tico a defini\u00e7\u00e3o de array \u00e9 diferente da de lista, um array aloca um espa\u00e7o de mem\u00f3ria contigo e fixo isso significa que uma vez declarado um array nestas linguagens ele vai ocupar aquele espa\u00e7o na mem\u00f3ria at\u00e9 o final da execu\u00e7\u00e3o do programa ou at\u00e9 um \"coletor de lixo\" ser acionado, enquanto as listas s\u00e3o estruturas din\u00e2micas no sentido de aloca\u00e7\u00e3o de mem\u00f3ria, podemos adicionar e remover valores dela sem problemas, em Python voc\u00ea n\u00e3o vai ter essa diferencia\u00e7\u00e3o, portanto vamos considerar por praticidade que arrays e listas s\u00e3o as mesmas entidades. NOTA: Python permite que voc\u00ea tenha uma lista com itens de tipo diferentes, mas \u00e9 importante dizer que voc\u00ea deve sempre querer trabalhar com cole\u00e7\u00f5es de somente um tipo de dados, isso evita muitos bugs no seu c\u00f3digo e \u00e9 uma boa pr\u00e1tica em programa\u00e7\u00e3o, se voc\u00ea esta ciente disso e prefere utilizar essa \"vantagem\" da linguagem use-a com cuidado. Declara\u00e7\u00e3o de uma Lista: \u00b6 lista = [] lista = [ 1 , 2 , 3 ] lista = [ '1' , 'a' , 'b' ] NOTE QUE: As declara\u00e7\u00f5es feitas acima seguem uma restri\u00e7\u00e3o imposta em nossa defini\u00e7\u00e3o, \u00e9 uma cole\u00e7\u00e3o de elementos ordenados e do mesmo tipo. Para entendermos melhor as lista \u00e9 importante saber que elas s\u00e3o estruturas indexadas, ou seja, cada elemento da lista tem uma posi\u00e7\u00e3o especifica nela que sempre come\u00e7a no valor 0 e termina no valor n -1 , onde n \u00e9 o numero de elementos que temos na lista. Acesso aos elementos: \u00b6 lista = [ 1 , 2 , 3 , 4 ] print ( lista [ 0 ]) 'Escreve no console o valor 1' print ( lista [ 1 ]) 'Escreve no console o valor 2' print ( lista [ 209 ]) 'Retorna um erro kkkkk' NOTE QUE: O erro ao escrever o item de posi\u00e7\u00e3o 209 no console j\u00e1 era esperado pois como dito anteriormente s\u00f3 temos acesso ao \u00edndice de valor n-1, onde n \u00e9 o numero de itens da lista. Adi\u00e7\u00e3o Unit\u00e1ria e de Cole\u00e7\u00f5es: \u00b6 lista = [] lista . append ( 1 ) 'Adiciona na posi\u00e7\u00e3o 0 da lista o valor 1' lista . append ( 2 ) 'Adiciona na posi\u00e7\u00e3o 1 da lista o valor 2' lista . insert ( 3 , 2 ) 'Adiciona na posi\u00e7\u00e3o 2 da lista o valor 3' lista [ 3 ] = 4 'Adiciona na posi\u00e7\u00e3o 3 da lista o valor 4' lista . extend ([ 5 , 6 ]) 'Adiciona na posi\u00e7\u00e3o 4 e 5 respectivamente os valores 5,6' lista_2 = [ 7 , 8 , 9 , 10 ] lista += lista_2 'Concatena a lista com a lista_2, mesmo efeito de extend' lista_2 *= 2 'Extende a lista com a pr\u00f3pria lista, ou seja, lista_2 = [7,8,9,10,7,8,9,10]'' Remo\u00e7\u00e3o Unit\u00e1ria e de Cole\u00e7\u00f5es: \u00b6 lista = [ 1 , 2 , 3 , 4 , 5 ] ultimo = lista . pop () 'Remove e retorna o ultimo item da lista, ou seja, lista = [1,2,3,4] e ultimo = 5' lista . remove ( 2 ) 'Remove a primeira ocorrencia do valor 2 da lista caso ele exista' Propriedades e outras fun\u00e7\u00f5es de Listas: \u00b6 lista = [ \"123\" , \"456\" ] comprimentoDaLista = len ( lista ) lista . reverse () 'O ultimos elementos da lista se tornam seus primeiros, ou seja, lista = [\"456\", \"123\"]' lista . sort () 'Ordena os elementos da lista de acordo com o tipo dos elementos, strings alfabeticamente, { int, float } crescente' lista . sort ( reverse = True ) 'Ordena os elementos da lista em ordem decrescente de acordo com a implementa\u00e7\u00e3o do tipo dos elementos' Percorrendo Listas: \u00b6 Bom como j\u00e1 passamos pelos Loops vamos ver como utiliza-los para percorrer nossas listas, podemos tamb\u00e9m realizar opera\u00e7\u00f5es enquanto percorremos elas, veremos os exemplos abaixo: lista = [ 1 , 2 , 3 , 4 , 5 ] for indice in range ( len ( lista )): print ( lista [ indice ]) Okay o algoritmo acima \u00e9 bem simples, ele s\u00f3 escreve no console os elementos da nossa lista, vamos ver exemplos um pouco mais complexos, aplicando filtros, e at\u00e9 mesmo gerando listas de maneira mais simples. Gera\u00e7\u00e3o e Filtragem de Listas: \u00b6 1-) Gerando uma Lista de 0 at\u00e9 n - 1 sem restri\u00e7\u00e3o: [ x for x in range ( 0 , int ( input ( \"Digite o limite da lista: \" )))] 2-) Gerando uma lista de 0 at\u00e9 n -1 somente com os valores pares: [ x for x in range ( 0 , int ( input ( \"Digite o limite da lista: \" ))) if x % 2 == 0 ] 3-) Gerando uma lista de 0 at\u00e9 n-1 pegando os valores \u00edmpares e elevando-os ao quadrado e os elementos pares multiplicados pelo seu sucessor: [ x ** 2 if x % 2 != 0 else x * ( x + 1 ) for x in range ( 0 , int ( input ( \"Digite o limite da lista: \" )))] Os exemplos acima podem sofrer modifica\u00e7\u00f5es de acordo com suas necessidades, essa sintaxe \u00e9 muito poderosa e basicamente permite quaisquer opera\u00e7\u00f5es com os dados durante a gera\u00e7\u00e3o da lista, aliada com as fun\u00e7\u00f5es temos uma ferramenta muito poderosa, mas vamos com calma. Bom vimos nos 3 exemplos acima que gerar listas em Python \u00e9 super simples, entretanto se j\u00e1 tivermos nossa base de dados armazenada em uma lista em Python como podemos apenas filtra-l\u00e1 de maneira simples, nos exemplos abaixo vamos simular isso. 1-) Temos uma lista de frutas e queremos filtrar para pegar apenas frutas que o nome comece com uma determinada letra: frutas = [ \"ma\u00e7\u00e3\" , \"pera\" , \"morango\" , \"uva\" , \"abacate\" , \"laranja\" , \"mam\u00e3o\" ] letra = input ( \"Digite a letra: \" ) 'list comprehension' frutasFiltrada = [ fruta for fruta in frutas if fruta [ 0 ] == letra ]","title":"Vetores"},{"location":"Basic/CollectionsTypes/array.html#declaracao-de-uma-lista","text":"lista = [] lista = [ 1 , 2 , 3 ] lista = [ '1' , 'a' , 'b' ] NOTE QUE: As declara\u00e7\u00f5es feitas acima seguem uma restri\u00e7\u00e3o imposta em nossa defini\u00e7\u00e3o, \u00e9 uma cole\u00e7\u00e3o de elementos ordenados e do mesmo tipo. Para entendermos melhor as lista \u00e9 importante saber que elas s\u00e3o estruturas indexadas, ou seja, cada elemento da lista tem uma posi\u00e7\u00e3o especifica nela que sempre come\u00e7a no valor 0 e termina no valor n -1 , onde n \u00e9 o numero de elementos que temos na lista.","title":"Declara\u00e7\u00e3o de uma Lista:"},{"location":"Basic/CollectionsTypes/array.html#acesso-aos-elementos","text":"lista = [ 1 , 2 , 3 , 4 ] print ( lista [ 0 ]) 'Escreve no console o valor 1' print ( lista [ 1 ]) 'Escreve no console o valor 2' print ( lista [ 209 ]) 'Retorna um erro kkkkk' NOTE QUE: O erro ao escrever o item de posi\u00e7\u00e3o 209 no console j\u00e1 era esperado pois como dito anteriormente s\u00f3 temos acesso ao \u00edndice de valor n-1, onde n \u00e9 o numero de itens da lista.","title":"Acesso aos elementos:"},{"location":"Basic/CollectionsTypes/array.html#adicao-unitaria-e-de-colecoes","text":"lista = [] lista . append ( 1 ) 'Adiciona na posi\u00e7\u00e3o 0 da lista o valor 1' lista . append ( 2 ) 'Adiciona na posi\u00e7\u00e3o 1 da lista o valor 2' lista . insert ( 3 , 2 ) 'Adiciona na posi\u00e7\u00e3o 2 da lista o valor 3' lista [ 3 ] = 4 'Adiciona na posi\u00e7\u00e3o 3 da lista o valor 4' lista . extend ([ 5 , 6 ]) 'Adiciona na posi\u00e7\u00e3o 4 e 5 respectivamente os valores 5,6' lista_2 = [ 7 , 8 , 9 , 10 ] lista += lista_2 'Concatena a lista com a lista_2, mesmo efeito de extend' lista_2 *= 2 'Extende a lista com a pr\u00f3pria lista, ou seja, lista_2 = [7,8,9,10,7,8,9,10]''","title":"Adi\u00e7\u00e3o Unit\u00e1ria e de Cole\u00e7\u00f5es:"},{"location":"Basic/CollectionsTypes/array.html#remocao-unitaria-e-de-colecoes","text":"lista = [ 1 , 2 , 3 , 4 , 5 ] ultimo = lista . pop () 'Remove e retorna o ultimo item da lista, ou seja, lista = [1,2,3,4] e ultimo = 5' lista . remove ( 2 ) 'Remove a primeira ocorrencia do valor 2 da lista caso ele exista'","title":"Remo\u00e7\u00e3o Unit\u00e1ria e de Cole\u00e7\u00f5es:"},{"location":"Basic/CollectionsTypes/array.html#propriedades-e-outras-funcoes-de-listas","text":"lista = [ \"123\" , \"456\" ] comprimentoDaLista = len ( lista ) lista . reverse () 'O ultimos elementos da lista se tornam seus primeiros, ou seja, lista = [\"456\", \"123\"]' lista . sort () 'Ordena os elementos da lista de acordo com o tipo dos elementos, strings alfabeticamente, { int, float } crescente' lista . sort ( reverse = True ) 'Ordena os elementos da lista em ordem decrescente de acordo com a implementa\u00e7\u00e3o do tipo dos elementos'","title":"Propriedades e outras fun\u00e7\u00f5es de Listas:"},{"location":"Basic/CollectionsTypes/array.html#percorrendo-listas","text":"Bom como j\u00e1 passamos pelos Loops vamos ver como utiliza-los para percorrer nossas listas, podemos tamb\u00e9m realizar opera\u00e7\u00f5es enquanto percorremos elas, veremos os exemplos abaixo: lista = [ 1 , 2 , 3 , 4 , 5 ] for indice in range ( len ( lista )): print ( lista [ indice ]) Okay o algoritmo acima \u00e9 bem simples, ele s\u00f3 escreve no console os elementos da nossa lista, vamos ver exemplos um pouco mais complexos, aplicando filtros, e at\u00e9 mesmo gerando listas de maneira mais simples.","title":"Percorrendo Listas:"},{"location":"Basic/CollectionsTypes/array.html#geracao-e-filtragem-de-listas","text":"1-) Gerando uma Lista de 0 at\u00e9 n - 1 sem restri\u00e7\u00e3o: [ x for x in range ( 0 , int ( input ( \"Digite o limite da lista: \" )))] 2-) Gerando uma lista de 0 at\u00e9 n -1 somente com os valores pares: [ x for x in range ( 0 , int ( input ( \"Digite o limite da lista: \" ))) if x % 2 == 0 ] 3-) Gerando uma lista de 0 at\u00e9 n-1 pegando os valores \u00edmpares e elevando-os ao quadrado e os elementos pares multiplicados pelo seu sucessor: [ x ** 2 if x % 2 != 0 else x * ( x + 1 ) for x in range ( 0 , int ( input ( \"Digite o limite da lista: \" )))] Os exemplos acima podem sofrer modifica\u00e7\u00f5es de acordo com suas necessidades, essa sintaxe \u00e9 muito poderosa e basicamente permite quaisquer opera\u00e7\u00f5es com os dados durante a gera\u00e7\u00e3o da lista, aliada com as fun\u00e7\u00f5es temos uma ferramenta muito poderosa, mas vamos com calma. Bom vimos nos 3 exemplos acima que gerar listas em Python \u00e9 super simples, entretanto se j\u00e1 tivermos nossa base de dados armazenada em uma lista em Python como podemos apenas filtra-l\u00e1 de maneira simples, nos exemplos abaixo vamos simular isso. 1-) Temos uma lista de frutas e queremos filtrar para pegar apenas frutas que o nome comece com uma determinada letra: frutas = [ \"ma\u00e7\u00e3\" , \"pera\" , \"morango\" , \"uva\" , \"abacate\" , \"laranja\" , \"mam\u00e3o\" ] letra = input ( \"Digite a letra: \" ) 'list comprehension' frutasFiltrada = [ fruta for fruta in frutas if fruta [ 0 ] == letra ]","title":"Gera\u00e7\u00e3o e Filtragem de Listas:"},{"location":"Basic/CollectionsTypes/dictionary.html","text":"","title":"Dicion\u00e1rios"},{"location":"Basic/CollectionsTypes/func.html","text":"","title":"Func"},{"location":"Basic/CollectionsTypes/matrix.html","text":"As matrizes s\u00e3o estruturas bem vers\u00e1teis em Python elas funcionam exatamente da mesma maneira que as listas, por defini\u00e7\u00e3o elas s\u00e3o listas de listas, ou seja teremos dois \u00edndices para o acesso de um elemento, o primeiro refere-se a linha e o segundo a coluna que queremos acessar, vamos ver como declarar uma matriz em Python e preenche-la. 1-) Lendo uma matriz: matriz = [] numLinhas = int ( input ( 'Digite o numero de linhas da matriz: ' )) for indice in range ( numLinhas ): linha = [ int ( x ) for x in input ( \"Digite os valores da Linha: \" ) . strip () . split ()] matriz [ indice ] = linha print ( f 'O primeiro elemento da primeira linha \u00e9 { matriz [ 0 ][ 0 ] } ' ) NOTE QUE: O acesso do elemento como dissemos \u00e9 feito por dois \u00edndices, e ambos iniciam com valor 0, como dito matrizes s\u00e3o listas de listas. 2-) Percorrendo a boa e velha matriz: matriz = [[ 1 , 2 , 3 , 4 ],[ 5 , 6 , 7 , 8 ]] for linha in range ( len ( matriz )): for coluna in range ( len ( matriz [ linha ])): print ( f 'O elemento da posi\u00e7\u00e3o [ { linha } ][ { coluna } ] = { matriz [ linha ][ coluna ] } ' ) Temos acima um loop aninhado, ou seja, para cada repeti\u00e7\u00e3o do primeiro loop teremos n repeti\u00e7\u00f5es, isso funciona para percorrer as matrizes pois note que para cada linhas temos n repeti\u00e7\u00f5es relativas a quantidade de colunas daquela linha, existe um outra maneira mais tranquila de percorrer sem usar os \u00edndices veja: matriz = [[ 1 , 2 , 3 , 4 ],[ 5 , 6 , 7 , 8 ]] for linha in matriz : for elemento in linha : print ( elemento ) Exerc\u00edcios: \u00b6 1-) Percorrer somente a coluna desejada pelo usu\u00e1rio: coluna = int ( input ( 'Digite o numero da coluna: ' )) - 1 matriz = [[ 1 , 2 , 3 , 4 ],[ 5 , 6 , 7 , 8 ]] for linha in matriz : print ( f ' { matriz . index ( linha ) + 1 } elemento da { coluna } coluna \u00e9 { linha [ coluna ] } ' ) NOTE QUE: Houve um decremento unit\u00e1rio no valor da coluna justamente pelo \u00edndice iniciar em 0, ou seja, a segunda coluna \u00e9 acessada pelo valor de \u00edndice 1. 2-) Percorrer somente a diagonal principal: matriz = [[ 1 , 2 ],[ 3 , 4 ]] for linha in matriz : index = matriz . index ( linha ) print ( f ' { index + 1 } elemento da diagonal principal \u00e9 { linha [ index ] } ' ) 3-) Percorrer somente a diagonal secundaria: matriz = [[ 1 , 2 ],[ 3 , 4 ]] for linha in matriz : index = matriz . index ( linha ) linha = linha [:: - 1 ] print ( f ' { index + 1 } elemento da diagonal secundaria \u00e9 { linha [ index ] } ' ) Ou ainda podemos gerar uma outra solu\u00e7\u00e3o: matriz = [[ 1 , 2 ],[ 3 , 4 ]] for linha in matriz : index = matriz . index ( linha ) print ( f ' { index + 1 } elemento da diagonal secundaria \u00e9 { linha [ len ( linha ) - 1 ] } ' ) Bom n\u00e3o tem muito segredo em trabalhar com matrizes uma vez que estamos trabalhando com as listas ainda, vamos ver uma situa\u00e7\u00e3o mais pr\u00e1tica sobre as matrizes simulando uma base de dados, claramente vamos cair em vetores com tipos de dados diferentes que s\u00e3o uma m\u00e1 pratica, entretanto para simular um banco de dados por hora basta, veremos mais tarde como resolver isso com outro tipo de dados. Imagine que voc\u00ea carrega em mem\u00f3ria uma tabela de um banco de dados relativa as vendas e voc\u00ea precisa extrair alguns dados dessa tabela. Por simplicidade uma venda tem as seguintes caracter\u00edsticas: Nome do Cliente; Nome do Vendedor; Nome do produto; Quantidade do produto; Valor do produto; Queremos saber qual o cliente que mais compra, qual o produto que mais vende e qual o vendedor com a maior m\u00e9dia no valor da venda. tabelaVendas = [[ 'Cliente' , 'Vendedor' , 'Produto' , 'Qtd' , 'Valor' ]] tabelaVendas [ 1 ] = [ 'Valter' , 'Alex' , 'Papel-A4' , 576 , 25.90 ] tabelaVendas [ 2 ] = [ 'Valter' , 'Anderson' , 'Borracha' , 120 , 2.95 ] tabelaVendas [ 3 ] = [ 'Thales' , 'Alex' , 'Papel-A4' , 180 , 25.90 ] tabelaVendas [ 3 ] = [ 'Thales' , 'Anderson' , 'Borracha' , 590 , 2.95 ] Percebam que acima definimos uma tabela com cabe\u00e7alho, vamos utilizar essa base de dados para resolver esse problema com matrizes. 'Cliente que mais compra' clientes = [ venda [ 0 ] if venda [ 0 ] not in clientes for venda in tabelaVendas [ 1 ::]] info = [] for cliente in clientes : totalVendas = 0 for venda in tabelaVendas : if ( venda [ 0 ] == cliente ): totalVendas += venda [ 4 ] * venda [ 3 ] info . append ([ cliente , totalVendas ]) NOTE QUE: Semanticamente esse c\u00f3digo n\u00e3o fica leg\u00edvel temos os chamados n\u00fameros m\u00e1gicos, eles s\u00e3o os \u00edndices de nossas colunas, por exemplo sem olhar o cabe\u00e7alho seria praticamente imposs\u00edvel sabermos oque a primeira coluna da matriz significa, esse problema ser\u00e1 resolvido com nossa pr\u00f3xima estrutura de dados, outro ponto \u00e9 sobre nossa lista de clientes existe uma estrutura de dados mais adequada para armazenar os clientes que veremos depois chamada set .","title":"Matrizes"},{"location":"Basic/CollectionsTypes/matrix.html#exercicios","text":"1-) Percorrer somente a coluna desejada pelo usu\u00e1rio: coluna = int ( input ( 'Digite o numero da coluna: ' )) - 1 matriz = [[ 1 , 2 , 3 , 4 ],[ 5 , 6 , 7 , 8 ]] for linha in matriz : print ( f ' { matriz . index ( linha ) + 1 } elemento da { coluna } coluna \u00e9 { linha [ coluna ] } ' ) NOTE QUE: Houve um decremento unit\u00e1rio no valor da coluna justamente pelo \u00edndice iniciar em 0, ou seja, a segunda coluna \u00e9 acessada pelo valor de \u00edndice 1. 2-) Percorrer somente a diagonal principal: matriz = [[ 1 , 2 ],[ 3 , 4 ]] for linha in matriz : index = matriz . index ( linha ) print ( f ' { index + 1 } elemento da diagonal principal \u00e9 { linha [ index ] } ' ) 3-) Percorrer somente a diagonal secundaria: matriz = [[ 1 , 2 ],[ 3 , 4 ]] for linha in matriz : index = matriz . index ( linha ) linha = linha [:: - 1 ] print ( f ' { index + 1 } elemento da diagonal secundaria \u00e9 { linha [ index ] } ' ) Ou ainda podemos gerar uma outra solu\u00e7\u00e3o: matriz = [[ 1 , 2 ],[ 3 , 4 ]] for linha in matriz : index = matriz . index ( linha ) print ( f ' { index + 1 } elemento da diagonal secundaria \u00e9 { linha [ len ( linha ) - 1 ] } ' ) Bom n\u00e3o tem muito segredo em trabalhar com matrizes uma vez que estamos trabalhando com as listas ainda, vamos ver uma situa\u00e7\u00e3o mais pr\u00e1tica sobre as matrizes simulando uma base de dados, claramente vamos cair em vetores com tipos de dados diferentes que s\u00e3o uma m\u00e1 pratica, entretanto para simular um banco de dados por hora basta, veremos mais tarde como resolver isso com outro tipo de dados. Imagine que voc\u00ea carrega em mem\u00f3ria uma tabela de um banco de dados relativa as vendas e voc\u00ea precisa extrair alguns dados dessa tabela. Por simplicidade uma venda tem as seguintes caracter\u00edsticas: Nome do Cliente; Nome do Vendedor; Nome do produto; Quantidade do produto; Valor do produto; Queremos saber qual o cliente que mais compra, qual o produto que mais vende e qual o vendedor com a maior m\u00e9dia no valor da venda. tabelaVendas = [[ 'Cliente' , 'Vendedor' , 'Produto' , 'Qtd' , 'Valor' ]] tabelaVendas [ 1 ] = [ 'Valter' , 'Alex' , 'Papel-A4' , 576 , 25.90 ] tabelaVendas [ 2 ] = [ 'Valter' , 'Anderson' , 'Borracha' , 120 , 2.95 ] tabelaVendas [ 3 ] = [ 'Thales' , 'Alex' , 'Papel-A4' , 180 , 25.90 ] tabelaVendas [ 3 ] = [ 'Thales' , 'Anderson' , 'Borracha' , 590 , 2.95 ] Percebam que acima definimos uma tabela com cabe\u00e7alho, vamos utilizar essa base de dados para resolver esse problema com matrizes. 'Cliente que mais compra' clientes = [ venda [ 0 ] if venda [ 0 ] not in clientes for venda in tabelaVendas [ 1 ::]] info = [] for cliente in clientes : totalVendas = 0 for venda in tabelaVendas : if ( venda [ 0 ] == cliente ): totalVendas += venda [ 4 ] * venda [ 3 ] info . append ([ cliente , totalVendas ]) NOTE QUE: Semanticamente esse c\u00f3digo n\u00e3o fica leg\u00edvel temos os chamados n\u00fameros m\u00e1gicos, eles s\u00e3o os \u00edndices de nossas colunas, por exemplo sem olhar o cabe\u00e7alho seria praticamente imposs\u00edvel sabermos oque a primeira coluna da matriz significa, esse problema ser\u00e1 resolvido com nossa pr\u00f3xima estrutura de dados, outro ponto \u00e9 sobre nossa lista de clientes existe uma estrutura de dados mais adequada para armazenar os clientes que veremos depois chamada set .","title":"Exerc\u00edcios:"},{"location":"Basic/CollectionsTypes/set.html","text":"","title":"Conjuntos"},{"location":"Basic/Functions/func.html","text":"As fun\u00e7\u00f5es s\u00e3o como pequenas abstra\u00e7\u00f5es mais gen\u00e9ricas no seu c\u00f3digo, i.e podemos definir partes menores de nosso algoritmo nome\u00e1-las e parametriza-las, se voc\u00ea j\u00e1 utilizou alguma biblioteca em Python deve ter percebido essa sintaxe len(array) , a fun\u00e7\u00e3o len() \u00e9 nativa da linguagem e retorna o comprimento de uma string, array etc. As fun\u00e7\u00f5es nativas de uma linguagem s\u00e3o fun\u00e7\u00f5es que n\u00e3o precisam ser definidas pelo programador como a pr\u00f3pria fun\u00e7\u00e3o len() , entretanto o programador pode definir suas fun\u00e7\u00f5es, veremos isso nos exemplos a seguir, antes disso \u00e9 importante entender o porque utilizar fun\u00e7\u00f5es e como elas podem te ajudar a estruturar melhor seu c\u00f3digo e evitar a repeti\u00e7\u00e3o dele. 1-) Vamos supor que voc\u00ea precisa criar um programa em Python que fa\u00e7a opera\u00e7\u00f5es b\u00e1sicas com matrizes ambas N x N. Antes de sair escrevendo seu c\u00f3digo vamos pensar nas coisas que precisamos fazer para que o algoritmo funcione: Ler Matrizes e armazena-las Escrever o c\u00f3digo para as opera\u00e7\u00f5es (Soma/Subtra\u00e7\u00e3o) Escrever o c\u00f3digo para apresentar o resultado C\u00f3digo sem utilizar fun\u00e7\u00f5es \u00b6 numeroDeLinhas = int ( input ( 'Insira o numero de Linhas das Matrizes: ' )) matriz1 = [] matriz2 = [] resultado = [] aux = 0 'Leitura Da Matriz e Armazenamento' while aux < 2 : print ( f ' \\n Insira a Matriz { aux + 1 } :' ) for i in range ( numeroDeLinhas ): linha = [ int ( x ) for x in input () . strip () . split ()] if aux == 0 : matriz1 . append ( linha ) elif aux == 1 : matriz2 . append ( linha ) aux += 1 'Desvio de Fluxo e Defini\u00e7\u00f5es de Opera\u00e7\u00f5es' operacao = int ( input ( ' \\n 1- Somar || 2-Subtrair: ' )) 'Defini\u00e7\u00e3o da Soma' if operacao == 1 : resultado = [[ matriz1 [ i ][ j ] + matriz2 [ i ][ j ] for j in range ( len ( matriz1 [ i ]))] for i in range ( len ( matriz1 ))] 'Defini\u00e7\u00e3o da Subtra\u00e7\u00e3o' elif operacao == 2 : resultado = [[ matriz1 [ i ][ j ] - matriz2 [ i ][ j ] for j in range ( len ( matriz1 [ i ]))] for i in range ( len ( matriz1 ))] 'Apresenta\u00e7\u00e3o do Resultado' print ( ' \\n RESULTADO:' ) for linha in resultado : print ( * linha , sep = ' ' ) O programa acima foi constru\u00eddo sem a utiliza\u00e7\u00e3o das fun\u00e7\u00f5es, independente se o algoritmo funciona devemos ter cuidado ao programar nossos algoritmos, o exemplo acima n\u00e3o permite o reuso do c\u00f3digo, a l\u00f3gica esta espalhada e n\u00e3o sabemos ao certo oque cada parte do c\u00f3digo faz sem que seja realizado um teste de mesa ou a leitura do c\u00f3digo. DICA: Se voc\u00ea precisa comentar o seu c\u00f3digo para entender o seu funcionamento considere reescrever ou revisar o mesmo. Algumas mudan\u00e7as podem deixar o c\u00f3digo mais leg\u00edvel, nomes de vari\u00e1veis e defini\u00e7\u00e3o de fun\u00e7\u00f5es s\u00e3o uma delas, vamos escrever o algoritmo utilizando as fun\u00e7\u00f5es. Primeiramente devemos entender o uso da palavra reservada def , quando utilizamos esta palavra em nosso c\u00f3digo estamos dizendo ao interpretador que vamos escrever uma fun\u00e7\u00e3o, logo ap\u00f3s a palavra def , nomeamos nossa fun\u00e7\u00e3o e parametrizamos ela, portanto def main() \u00e9 a defini\u00e7\u00e3o de nossa fun\u00e7\u00e3o principal, \u00e9 importante entender que a fun\u00e7\u00e3o main \u00e9 especial no nosso c\u00f3digo, ela que comandara a execu\u00e7\u00e3o do nosso programa como veremos no exemplo abaixo: Sintaxe Das Fun\u00e7\u00f5es \u00b6 def main (): print ( 'Ola mundo' ) main () NOTE QUE: O c\u00f3digo acima define a fun\u00e7\u00e3o main e chama a mesma para ser executada. def ParOuImpar ( numero : int ) -> str : if ( numero % 2 == 0 ): return \"PAR\" return \"IMPAR\" def main (): numero = int ( input ( \"Digite um numero para indentificar sua Paridade: \" )) print ( f ' { numero } \u00e9 { ParOuImpar ( numero ) } ' ) main () NOTE QUE: ParOuImpar \u00e9 uma fun\u00e7\u00e3o que tem um par\u00e2metro do tipo inteiro e retorna uma string. def ParOuImpar ( numero ): if ( numero % 2 == 0 ) return \"PAR\" return \"IMPAR\" def main (): numero = int ( input ( \"Digite um numero para indentificar sua Paridade: \" )) print ( f ' { numero } \u00e9 { ParOuImpar ( numero ) } ' ) main () Acima podemos ver que a sintaxe usada na defini\u00e7\u00e3o de ParOuImpar \u00e9 diferente, entretanto semanticamente n\u00e3o temos diferen\u00e7as, devemos levar em conta que escrever c\u00f3digo \u00e9 menos trabalhoso que ler, compreender e explicar, logo utilizar a sintaxe mais verbosa dizendo o tipo dos par\u00e2metros e de retorno \u00e9 interessante pois serve como \"documenta\u00e7\u00e3o\" para outros programadores que utilizaram seu c\u00f3digo, outras linguagens de programa\u00e7\u00e3o obrigam a especifica\u00e7\u00e3o dos tipos ent\u00e3o considere utilizar a especifica\u00e7\u00e3o de tipo se pretende programar em outras linguagens. C\u00f3digo utilizando fun\u00e7\u00f5es \u00b6 'Nesta fun\u00e7\u00e3o estamos utilizando a sintaxe mais verbosa onde dizemos qual o tipo de retorno e do parametro' def LerMatriz ( qtdLinhas : int ) -> list ( list ( int )): \"\"\"Le um Matriz de Inteiros\"\"\" matriz = [] print ( \"Insira as Linhas da Matriz:\" ) for i in range ( qtdLinhas ): linha = [ int ( x ) for x in input () . strip () . split ()] matriz . append ( linha ) return matriz def SomaMatrizes ( m1 : list ( list ( int )), m2 : list ( list ( int ))) -> list ( list ( int )): \"\"\"Soma duas Matrizes de Inteiros\"\"\" return [[ m1 [ i ][ j ] + m2 [ i ][ j ] for j in range ( len ( m1 [ 0 ]))] for i in range ( len ( m1 ))] 'Nesta fun\u00e7\u00e3o estamos utilizando a sintaxe menos verbosa onde n\u00e3o especificamos os tipos dos parametros e retorno' def SubtracaoMatrizes ( m1 , m2 ): \"\"\"Subtrai duas Matrizes de Inteiros\"\"\" return [[ m1 [ i ][ j ] - m2 [ i ][ j ] for j in range ( len ( m1 [ 0 ]))] for i in range ( len ( m1 ))] def ApresentaMatriz ( m : list ( list ( int ))) -> None : \"\"\"Apresenta uma Matriz de Inteiros\"\"\" for linha in m : print ( * linha , sep = \" \" ) 'Como dito anteriormente temos a fun\u00e7\u00e3o main que controla a execu\u00e7\u00e3o do programa' def main (): qtdLinhas = int ( input ( \"Digite o numero de linhas das Matrizes: \" )) print ( ' \\n MATRIZ 1:' ) m1 = LerMatriz ( qtdLinhas ) print ( ' \\n MATRIZ 2:' ) m2 = LerMatriz ( qtdLinhas ) print ( ' \\n SOMA DE MATRIZES:' ) ApresentaMatriz ( SomaMatrizes ( m1 , m2 )) 'Assim chamamos uma fun\u00e7\u00e3o main' main () NOTE QUE: Escrevemos coment\u00e1rios com 3 aspas duplas abaixo das defini\u00e7\u00f5es, isso permite que programadores que v\u00e3o utilizar nosso m\u00e9todos leiam e compreendam seu funcionamento, al\u00e9m disso se voc\u00ea for um programador legal e explicitar os tipos de par\u00e2metros e retorno essas informa\u00e7\u00f5es tamb\u00e9m aparecem nessa pequena documenta\u00e7\u00e3o, mas aten\u00e7\u00e3o essa documenta\u00e7\u00e3o deve ser sempre sucinta e objetiva.","title":"Fun\u00e7\u00f5es (def)"},{"location":"Basic/Functions/func.html#codigo-sem-utilizar-funcoes","text":"numeroDeLinhas = int ( input ( 'Insira o numero de Linhas das Matrizes: ' )) matriz1 = [] matriz2 = [] resultado = [] aux = 0 'Leitura Da Matriz e Armazenamento' while aux < 2 : print ( f ' \\n Insira a Matriz { aux + 1 } :' ) for i in range ( numeroDeLinhas ): linha = [ int ( x ) for x in input () . strip () . split ()] if aux == 0 : matriz1 . append ( linha ) elif aux == 1 : matriz2 . append ( linha ) aux += 1 'Desvio de Fluxo e Defini\u00e7\u00f5es de Opera\u00e7\u00f5es' operacao = int ( input ( ' \\n 1- Somar || 2-Subtrair: ' )) 'Defini\u00e7\u00e3o da Soma' if operacao == 1 : resultado = [[ matriz1 [ i ][ j ] + matriz2 [ i ][ j ] for j in range ( len ( matriz1 [ i ]))] for i in range ( len ( matriz1 ))] 'Defini\u00e7\u00e3o da Subtra\u00e7\u00e3o' elif operacao == 2 : resultado = [[ matriz1 [ i ][ j ] - matriz2 [ i ][ j ] for j in range ( len ( matriz1 [ i ]))] for i in range ( len ( matriz1 ))] 'Apresenta\u00e7\u00e3o do Resultado' print ( ' \\n RESULTADO:' ) for linha in resultado : print ( * linha , sep = ' ' ) O programa acima foi constru\u00eddo sem a utiliza\u00e7\u00e3o das fun\u00e7\u00f5es, independente se o algoritmo funciona devemos ter cuidado ao programar nossos algoritmos, o exemplo acima n\u00e3o permite o reuso do c\u00f3digo, a l\u00f3gica esta espalhada e n\u00e3o sabemos ao certo oque cada parte do c\u00f3digo faz sem que seja realizado um teste de mesa ou a leitura do c\u00f3digo. DICA: Se voc\u00ea precisa comentar o seu c\u00f3digo para entender o seu funcionamento considere reescrever ou revisar o mesmo. Algumas mudan\u00e7as podem deixar o c\u00f3digo mais leg\u00edvel, nomes de vari\u00e1veis e defini\u00e7\u00e3o de fun\u00e7\u00f5es s\u00e3o uma delas, vamos escrever o algoritmo utilizando as fun\u00e7\u00f5es. Primeiramente devemos entender o uso da palavra reservada def , quando utilizamos esta palavra em nosso c\u00f3digo estamos dizendo ao interpretador que vamos escrever uma fun\u00e7\u00e3o, logo ap\u00f3s a palavra def , nomeamos nossa fun\u00e7\u00e3o e parametrizamos ela, portanto def main() \u00e9 a defini\u00e7\u00e3o de nossa fun\u00e7\u00e3o principal, \u00e9 importante entender que a fun\u00e7\u00e3o main \u00e9 especial no nosso c\u00f3digo, ela que comandara a execu\u00e7\u00e3o do nosso programa como veremos no exemplo abaixo:","title":"C\u00f3digo sem utilizar fun\u00e7\u00f5es"},{"location":"Basic/Functions/func.html#sintaxe-das-funcoes","text":"def main (): print ( 'Ola mundo' ) main () NOTE QUE: O c\u00f3digo acima define a fun\u00e7\u00e3o main e chama a mesma para ser executada. def ParOuImpar ( numero : int ) -> str : if ( numero % 2 == 0 ): return \"PAR\" return \"IMPAR\" def main (): numero = int ( input ( \"Digite um numero para indentificar sua Paridade: \" )) print ( f ' { numero } \u00e9 { ParOuImpar ( numero ) } ' ) main () NOTE QUE: ParOuImpar \u00e9 uma fun\u00e7\u00e3o que tem um par\u00e2metro do tipo inteiro e retorna uma string. def ParOuImpar ( numero ): if ( numero % 2 == 0 ) return \"PAR\" return \"IMPAR\" def main (): numero = int ( input ( \"Digite um numero para indentificar sua Paridade: \" )) print ( f ' { numero } \u00e9 { ParOuImpar ( numero ) } ' ) main () Acima podemos ver que a sintaxe usada na defini\u00e7\u00e3o de ParOuImpar \u00e9 diferente, entretanto semanticamente n\u00e3o temos diferen\u00e7as, devemos levar em conta que escrever c\u00f3digo \u00e9 menos trabalhoso que ler, compreender e explicar, logo utilizar a sintaxe mais verbosa dizendo o tipo dos par\u00e2metros e de retorno \u00e9 interessante pois serve como \"documenta\u00e7\u00e3o\" para outros programadores que utilizaram seu c\u00f3digo, outras linguagens de programa\u00e7\u00e3o obrigam a especifica\u00e7\u00e3o dos tipos ent\u00e3o considere utilizar a especifica\u00e7\u00e3o de tipo se pretende programar em outras linguagens.","title":"Sintaxe Das Fun\u00e7\u00f5es"},{"location":"Basic/Functions/func.html#codigo-utilizando-funcoes","text":"'Nesta fun\u00e7\u00e3o estamos utilizando a sintaxe mais verbosa onde dizemos qual o tipo de retorno e do parametro' def LerMatriz ( qtdLinhas : int ) -> list ( list ( int )): \"\"\"Le um Matriz de Inteiros\"\"\" matriz = [] print ( \"Insira as Linhas da Matriz:\" ) for i in range ( qtdLinhas ): linha = [ int ( x ) for x in input () . strip () . split ()] matriz . append ( linha ) return matriz def SomaMatrizes ( m1 : list ( list ( int )), m2 : list ( list ( int ))) -> list ( list ( int )): \"\"\"Soma duas Matrizes de Inteiros\"\"\" return [[ m1 [ i ][ j ] + m2 [ i ][ j ] for j in range ( len ( m1 [ 0 ]))] for i in range ( len ( m1 ))] 'Nesta fun\u00e7\u00e3o estamos utilizando a sintaxe menos verbosa onde n\u00e3o especificamos os tipos dos parametros e retorno' def SubtracaoMatrizes ( m1 , m2 ): \"\"\"Subtrai duas Matrizes de Inteiros\"\"\" return [[ m1 [ i ][ j ] - m2 [ i ][ j ] for j in range ( len ( m1 [ 0 ]))] for i in range ( len ( m1 ))] def ApresentaMatriz ( m : list ( list ( int ))) -> None : \"\"\"Apresenta uma Matriz de Inteiros\"\"\" for linha in m : print ( * linha , sep = \" \" ) 'Como dito anteriormente temos a fun\u00e7\u00e3o main que controla a execu\u00e7\u00e3o do programa' def main (): qtdLinhas = int ( input ( \"Digite o numero de linhas das Matrizes: \" )) print ( ' \\n MATRIZ 1:' ) m1 = LerMatriz ( qtdLinhas ) print ( ' \\n MATRIZ 2:' ) m2 = LerMatriz ( qtdLinhas ) print ( ' \\n SOMA DE MATRIZES:' ) ApresentaMatriz ( SomaMatrizes ( m1 , m2 )) 'Assim chamamos uma fun\u00e7\u00e3o main' main () NOTE QUE: Escrevemos coment\u00e1rios com 3 aspas duplas abaixo das defini\u00e7\u00f5es, isso permite que programadores que v\u00e3o utilizar nosso m\u00e9todos leiam e compreendam seu funcionamento, al\u00e9m disso se voc\u00ea for um programador legal e explicitar os tipos de par\u00e2metros e retorno essas informa\u00e7\u00f5es tamb\u00e9m aparecem nessa pequena documenta\u00e7\u00e3o, mas aten\u00e7\u00e3o essa documenta\u00e7\u00e3o deve ser sempre sucinta e objetiva.","title":"C\u00f3digo utilizando fun\u00e7\u00f5es"},{"location":"Basic/Functions/lambda.html","text":"Sintaxe \u00b6 Antes de qualquer coisa vamos apresentar a sintaxe das fun\u00e7\u00f5es lambda: 1-) Criar uma express\u00e3o lambda para verificar paridade de um numero: fParidade = lambda numero : \"PAR\" if numero % 2 == 0 else \"IMPAR\" NOTE QUE: Ao utilizarmos a palavra reservada lambda devemos nomea-la atribuindo-a para uma vari\u00e1vel no exemplo acima nomeamos-a fParidade , logo ap\u00f3s a palavra reservada devemos escrever os par\u00e2metros da fun\u00e7\u00e3o, ou seja, nossa fun\u00e7\u00e3o lambda acima \u00e9 uma fun\u00e7\u00e3o que tem somente um par\u00e2metro chamado numero , ap\u00f3s dizermos os par\u00e2metros definimos a fun\u00e7\u00e3o depois do caractere '' : '' , no exemplo acima utilizamos uma estrutura condicional para definir o retorno, quando utilizamos um condicional em uma express\u00e3o lambda devemos primeiro escrever o retorno para a condi\u00e7\u00e3o verdadeira, em seguida a condi\u00e7\u00e3o com if e por fim a palavra reservada else e o retorno se falsa. 2-) Criar uma express\u00e3o lambda que tenha dois par\u00e2metros x e y e retorne x ^ y : fPotencia = lambda x , y : x ** y Acima temos uma express\u00e3o lambda com mais de um par\u00e2metro, teoricamente podemos definir quantos par\u00e2metros quisermos, mas perceba que o intuito desta sintaxe \u00e9 definir fun\u00e7\u00f5es simples sem precisar usar uma defini\u00e7\u00e3o mais verbosa como def . Bom com essa pequena introdu\u00e7\u00e3o acima vamos reescrever o exerc\u00edcio das matrizes somente com express\u00f5es lambda, vamos ver na pratica quando utiliza-las e quando n\u00e3o. Quando n\u00e3o utilizar? \u00b6 1-) Vamos supor que voc\u00ea precisa criar um programa em Python que fa\u00e7a opera\u00e7\u00f5es b\u00e1sicas com matrizes ambas N x N. Antes de sair escrevendo seu c\u00f3digo vamos pensar nas coisas que precisamos fazer para que o algoritmo funcione: Ler Matrizes e armazena-las Escrever o c\u00f3digo para as opera\u00e7\u00f5es (Soma/Subtra\u00e7\u00e3o) Escrever o c\u00f3digo para apresentar o resultado SHOW ME THE CODE KKK: LerLinha = lambda : list ( map ( lambda elemento : int ( elemento ) , input () . strip () . split ())) LerMatriz = lambda qtdLinhas : list ( map ( lambda matriz : list ( map ( lambda linha : linha , LerLinha ())), range ( qtdLinhas ))) SomaMatrizes = lambda m1 , m2 : list ( map ( lambda x : list ( map ( lambda y : m1 [ x ][ y ] + m2 [ x ][ y ], range ( len ( m1 [ 0 ])))), range ( len ( m1 )))) SubtraiMatrizes = lambda m1 , m2 : list ( map ( lambda x : list ( map ( lambda y : m1 [ x ][ y ] - m2 [ x ][ y ], range ( len ( m1 [ 0 ])))), range ( len ( m1 )))) ApresentaMatriz = lambda matriz : [ print ( * linha , sep = \" \" ) for linha in matriz ] def main (): qtdLinhas = int ( input ( \"Digite o numero de Linhas da Matriz: \" )) print ( ' \\n MATRIZ 1:' ) m1 = LerMatriz ( qtdLinhas ) print ( ' \\n MATRIZ 2:' ) m2 = LerMatriz ( qtdLinhas ) print ( ' \\n SOMA DE MATRIZES:' ) ApresentaMatriz ( SomaMatrizes ( m1 , m2 )) print ( ' \\n SUBTRA\u00c7\u00c3O DE MATRIZES:' ) ApresentaMatriz ( SubtraiMatrizes ( m1 , m2 )) main () N\u00e3o se assunte se voc\u00ea n\u00e3o entendeu o c\u00f3digo acima, ele \u00e9 um exemplo de abuso do uso de express\u00f5es lambda , o primeiro questionamento que voc\u00ea deve fazer ao escrever um c\u00f3digo \u00e9 se ele \u00e9 leg\u00edvel, olhando para o c\u00f3digo acima \u00e9 muito dif\u00edcil entender oque cada fun\u00e7\u00e3o faz sem realizar a leitura de seus nomes, outro problema \u00e9 a composi\u00e7\u00e3o de express\u00f5es lambda , assim como a defini\u00e7\u00e3o de fun\u00e7\u00f5es dentro de fun\u00e7\u00f5es \u00e9 uma pratica ruim a composi\u00e7\u00e3o de lambdas tamb\u00e9m \u00e9, a conclus\u00e3o \u00e9 que devemos ter bom senso ao tentar reduzir as linhas de nosso programa, devemos sempre nos preocupar com a legibilidade e simplicidade da nossa solu\u00e7\u00e3o, e por fim a documenta\u00e7\u00e3o vimos que quando utilizamos a palavra reservada def podemos usar um coment\u00e1rio com 3 aspas duplas para dar uma no\u00e7\u00e3o aos outros programadores sobre o funcionamento do nosso m\u00e9todo al\u00e9m disso vimos que podemos explicitar os tipos dos par\u00e2metros e retorno de nossas fun\u00e7\u00f5es, ambas as opera\u00e7\u00f5es n\u00e3o s\u00e3o poss\u00edveis com a a sintaxe lambda . \u201cQualquer tolo consegue escrever c\u00f3digo que um computador entenda. Bons programadores escrevem c\u00f3digo que humanos possam entender.\u201d Martin Fowler Quando utilizar ? \u00b6 Agora vamos ver casos de uso para lambda functions que fazem sentido. 1-) Fa\u00e7a uma fun\u00e7\u00e3o de filtro que receba um array e pegue somente numeros pares: filtro = lambda numero : True if numero % 2 == 0 else False ''' Vamos aplicar esse filtro ''' pares = filter ( filtro ,[ 1 , 2 , 3 , 4 ]) print ( * pares , sep = \" \" ) 2-) Fa\u00e7a uma fun\u00e7\u00e3o que dado um valor n retorne o en\u00e9simo elemento da sequencia de Fibonacci: fibonacci = lambda n : 1 / ( 5 ** 0.5 ) * ( ( ( 1 + 5 ** 0.5 ) / 2 ) ** n - ( ( 1 - 5 ** 0.5 ) / 2 ) ** n ) n = int ( input ( \"Insira n: \" )) print ( fibonacci ( n ))","title":"Express\u00f5es Lambda (lambda)"},{"location":"Basic/Functions/lambda.html#sintaxe","text":"Antes de qualquer coisa vamos apresentar a sintaxe das fun\u00e7\u00f5es lambda: 1-) Criar uma express\u00e3o lambda para verificar paridade de um numero: fParidade = lambda numero : \"PAR\" if numero % 2 == 0 else \"IMPAR\" NOTE QUE: Ao utilizarmos a palavra reservada lambda devemos nomea-la atribuindo-a para uma vari\u00e1vel no exemplo acima nomeamos-a fParidade , logo ap\u00f3s a palavra reservada devemos escrever os par\u00e2metros da fun\u00e7\u00e3o, ou seja, nossa fun\u00e7\u00e3o lambda acima \u00e9 uma fun\u00e7\u00e3o que tem somente um par\u00e2metro chamado numero , ap\u00f3s dizermos os par\u00e2metros definimos a fun\u00e7\u00e3o depois do caractere '' : '' , no exemplo acima utilizamos uma estrutura condicional para definir o retorno, quando utilizamos um condicional em uma express\u00e3o lambda devemos primeiro escrever o retorno para a condi\u00e7\u00e3o verdadeira, em seguida a condi\u00e7\u00e3o com if e por fim a palavra reservada else e o retorno se falsa. 2-) Criar uma express\u00e3o lambda que tenha dois par\u00e2metros x e y e retorne x ^ y : fPotencia = lambda x , y : x ** y Acima temos uma express\u00e3o lambda com mais de um par\u00e2metro, teoricamente podemos definir quantos par\u00e2metros quisermos, mas perceba que o intuito desta sintaxe \u00e9 definir fun\u00e7\u00f5es simples sem precisar usar uma defini\u00e7\u00e3o mais verbosa como def . Bom com essa pequena introdu\u00e7\u00e3o acima vamos reescrever o exerc\u00edcio das matrizes somente com express\u00f5es lambda, vamos ver na pratica quando utiliza-las e quando n\u00e3o.","title":"Sintaxe"},{"location":"Basic/Functions/lambda.html#quando-nao-utilizar","text":"1-) Vamos supor que voc\u00ea precisa criar um programa em Python que fa\u00e7a opera\u00e7\u00f5es b\u00e1sicas com matrizes ambas N x N. Antes de sair escrevendo seu c\u00f3digo vamos pensar nas coisas que precisamos fazer para que o algoritmo funcione: Ler Matrizes e armazena-las Escrever o c\u00f3digo para as opera\u00e7\u00f5es (Soma/Subtra\u00e7\u00e3o) Escrever o c\u00f3digo para apresentar o resultado SHOW ME THE CODE KKK: LerLinha = lambda : list ( map ( lambda elemento : int ( elemento ) , input () . strip () . split ())) LerMatriz = lambda qtdLinhas : list ( map ( lambda matriz : list ( map ( lambda linha : linha , LerLinha ())), range ( qtdLinhas ))) SomaMatrizes = lambda m1 , m2 : list ( map ( lambda x : list ( map ( lambda y : m1 [ x ][ y ] + m2 [ x ][ y ], range ( len ( m1 [ 0 ])))), range ( len ( m1 )))) SubtraiMatrizes = lambda m1 , m2 : list ( map ( lambda x : list ( map ( lambda y : m1 [ x ][ y ] - m2 [ x ][ y ], range ( len ( m1 [ 0 ])))), range ( len ( m1 )))) ApresentaMatriz = lambda matriz : [ print ( * linha , sep = \" \" ) for linha in matriz ] def main (): qtdLinhas = int ( input ( \"Digite o numero de Linhas da Matriz: \" )) print ( ' \\n MATRIZ 1:' ) m1 = LerMatriz ( qtdLinhas ) print ( ' \\n MATRIZ 2:' ) m2 = LerMatriz ( qtdLinhas ) print ( ' \\n SOMA DE MATRIZES:' ) ApresentaMatriz ( SomaMatrizes ( m1 , m2 )) print ( ' \\n SUBTRA\u00c7\u00c3O DE MATRIZES:' ) ApresentaMatriz ( SubtraiMatrizes ( m1 , m2 )) main () N\u00e3o se assunte se voc\u00ea n\u00e3o entendeu o c\u00f3digo acima, ele \u00e9 um exemplo de abuso do uso de express\u00f5es lambda , o primeiro questionamento que voc\u00ea deve fazer ao escrever um c\u00f3digo \u00e9 se ele \u00e9 leg\u00edvel, olhando para o c\u00f3digo acima \u00e9 muito dif\u00edcil entender oque cada fun\u00e7\u00e3o faz sem realizar a leitura de seus nomes, outro problema \u00e9 a composi\u00e7\u00e3o de express\u00f5es lambda , assim como a defini\u00e7\u00e3o de fun\u00e7\u00f5es dentro de fun\u00e7\u00f5es \u00e9 uma pratica ruim a composi\u00e7\u00e3o de lambdas tamb\u00e9m \u00e9, a conclus\u00e3o \u00e9 que devemos ter bom senso ao tentar reduzir as linhas de nosso programa, devemos sempre nos preocupar com a legibilidade e simplicidade da nossa solu\u00e7\u00e3o, e por fim a documenta\u00e7\u00e3o vimos que quando utilizamos a palavra reservada def podemos usar um coment\u00e1rio com 3 aspas duplas para dar uma no\u00e7\u00e3o aos outros programadores sobre o funcionamento do nosso m\u00e9todo al\u00e9m disso vimos que podemos explicitar os tipos dos par\u00e2metros e retorno de nossas fun\u00e7\u00f5es, ambas as opera\u00e7\u00f5es n\u00e3o s\u00e3o poss\u00edveis com a a sintaxe lambda . \u201cQualquer tolo consegue escrever c\u00f3digo que um computador entenda. Bons programadores escrevem c\u00f3digo que humanos possam entender.\u201d Martin Fowler","title":"Quando n\u00e3o utilizar?"},{"location":"Basic/Functions/lambda.html#quando-utilizar","text":"Agora vamos ver casos de uso para lambda functions que fazem sentido. 1-) Fa\u00e7a uma fun\u00e7\u00e3o de filtro que receba um array e pegue somente numeros pares: filtro = lambda numero : True if numero % 2 == 0 else False ''' Vamos aplicar esse filtro ''' pares = filter ( filtro ,[ 1 , 2 , 3 , 4 ]) print ( * pares , sep = \" \" ) 2-) Fa\u00e7a uma fun\u00e7\u00e3o que dado um valor n retorne o en\u00e9simo elemento da sequencia de Fibonacci: fibonacci = lambda n : 1 / ( 5 ** 0.5 ) * ( ( ( 1 + 5 ** 0.5 ) / 2 ) ** n - ( ( 1 - 5 ** 0.5 ) / 2 ) ** n ) n = int ( input ( \"Insira n: \" )) print ( fibonacci ( n ))","title":"Quando utilizar ?"},{"location":"Basic/IO/io.html","text":"","title":"Console IO"},{"location":"Basic/PrimitiveTypes/types.html","text":"Num\u00e9ricos \u00b6 Semelhante \u00e0 outras linguagens, Python apresenta tipo inteiro e de ponto flutuante: x = 8 print ( x , type ( x )) Opera\u00e7\u00f5es \u00b6 print ( x + 3 ) # Adi\u00e7\u00e3o; print ( x - 3 ) # Subtra\u00e7\u00e3o; print ( x * 3 ) # Multiplica\u00e7\u00e3o; print ( x ** 3 ) # Exponencia\u00e7\u00e3o; x += 1 print ( x ) x *= 2 print ( x ) y = x / 2 print ( type ( y )) print ( y , y + 1 , y * 2 , y ** 2 ) Veja que Python n\u00e3o tem operadores de incremento e decremento unit\u00e1rio (x++) Exerc\u00edcios 1-) Programe as formulas de juros simples e composto. *Taxa de 1% ao ano , periodo de 2 anos e capital de $1000. '''Juros Simples''' Montante = 1000 * ( 1 + 1 / 100 * 2 ) '''Juros Compostos''' Montante = 1000 * ( 1 + 1 / 100 ) ** 2 Booleanos \u00b6 Strings \u00b6","title":"Tipos Primitivos"},{"location":"Basic/PrimitiveTypes/types.html#numericos","text":"Semelhante \u00e0 outras linguagens, Python apresenta tipo inteiro e de ponto flutuante: x = 8 print ( x , type ( x ))","title":"Num\u00e9ricos"},{"location":"Basic/PrimitiveTypes/types.html#operacoes","text":"print ( x + 3 ) # Adi\u00e7\u00e3o; print ( x - 3 ) # Subtra\u00e7\u00e3o; print ( x * 3 ) # Multiplica\u00e7\u00e3o; print ( x ** 3 ) # Exponencia\u00e7\u00e3o; x += 1 print ( x ) x *= 2 print ( x ) y = x / 2 print ( type ( y )) print ( y , y + 1 , y * 2 , y ** 2 ) Veja que Python n\u00e3o tem operadores de incremento e decremento unit\u00e1rio (x++) Exerc\u00edcios 1-) Programe as formulas de juros simples e composto. *Taxa de 1% ao ano , periodo de 2 anos e capital de $1000. '''Juros Simples''' Montante = 1000 * ( 1 + 1 / 100 * 2 ) '''Juros Compostos''' Montante = 1000 * ( 1 + 1 / 100 ) ** 2","title":"Opera\u00e7\u00f5es"},{"location":"Basic/PrimitiveTypes/types.html#booleanos","text":"","title":"Booleanos"},{"location":"Basic/PrimitiveTypes/types.html#strings","text":"","title":"Strings"},{"location":"Basic/Structs/conditional.html","text":"","title":"Estruturas de Condi\u00e7\u00e3o"},{"location":"Basic/Structs/loop.html","text":"While \u00b6 .justify {text-align: justify;text-justify: inter-word;} O loop While \u00e9 uma estrutura de repeti\u00e7\u00e3o muito simples e funcional, sua vantagem \u00e9 de suportar varias condi\u00e7\u00f5es destintas simultaneamente, entretanto este loop precisa de vari\u00e1veis de controle para que o algoritmo n\u00e3o entre em loop infinito. y = 3 x = 0 while x < y : print ( f 'X eh menor que Y. { x } < { y } ' ) x += 1 NOTE QUE: O loop do exemplo acima realiza 2 itera\u00e7\u00f5es, ele \u00e9 um exemplo de um loop while com uma condi\u00e7\u00e3o. z = 7 y = 5 x = 0 while x < y and y < z : print ( f 'X eh menor que Y e Y eh menor que Z' ) x += 1 y += 1 NOTE QUE: O loop do exemplo acima realiza 2 itera\u00e7\u00f5es, ele \u00e9 um exemplo de um loop while com mais de uma condi\u00e7\u00e3o. For Loop \u00b6 O loop For \u00e9 uma estrutura de repeti\u00e7\u00e3o bem interessante em Python, a sua vantagem em rela\u00e7\u00e3o ao loop while \u00e9 que n\u00e3o precisa da declara\u00e7\u00e3o de uma vari\u00e1vel de controle e sua sintaxe \u00e9 bastante simples e vers\u00e1til. inicio = 1 'O inicio \u00e9 incluido' final = 10 'O final n\u00e3o \u00e9 incluido' incremento = 5 'O incremento que vamos fazer para chegar no final' for x in range ( inicio , final , incremento ): print ( f ' { x } ' ) Podemos ver que a estrutura de repeti\u00e7\u00e3o for \u00e9 bem simples de entender, ela utiliza uma palavra in reservada e uma fun\u00e7\u00e3o range() , ou seja, semanticamente estamos dizendo \"para x no intervalo [ in\u00edcio , final - 1] pulando x de incremento em incremento\" fa\u00e7a alguma coisa. No caso do exemplo acima o la\u00e7o vai iterar duas vezes vamos esquematizar: for x in range ( 3 , 20 , 2 ): print ( f ' { x } ' ) Bom o c\u00f3digo acima demonstra a defini\u00e7\u00e3o de um loop for que s\u00f3 escreve no console os n\u00fameros \u00edmpares at\u00e9 19, a fun\u00e7\u00e3o range() pode gerar um tanto intervalo crescente quanto decrescente, vejamos um exemplo a seguir de um loop decrescente que imprime no console somente os n\u00fameros pares do intervalo: for x in range ( 20 , 3 , - 2 ): print ( f ' { x } ' ) NOTE QUE: Passamos o par\u00e2metro de incremento como negativo, caso contrario o intervalo n\u00e3o ser\u00e1 gerado e n\u00e3o vamos iterar no loop . Existe ainda uma ultima maneira de utilizar a fun\u00e7\u00e3o range() no loop for , passando somente um int como par\u00e2metro o intervalo gerado vai de 0 at\u00e9 uma unidade anterior ao par\u00e2metro com incremento unit\u00e1rio: for x in range ( 3 ): print ( f ' { x } ' )","title":"Estruturas de Repeti\u00e7\u00e3o"},{"location":"Basic/Structs/loop.html#while","text":".justify {text-align: justify;text-justify: inter-word;} O loop While \u00e9 uma estrutura de repeti\u00e7\u00e3o muito simples e funcional, sua vantagem \u00e9 de suportar varias condi\u00e7\u00f5es destintas simultaneamente, entretanto este loop precisa de vari\u00e1veis de controle para que o algoritmo n\u00e3o entre em loop infinito. y = 3 x = 0 while x < y : print ( f 'X eh menor que Y. { x } < { y } ' ) x += 1 NOTE QUE: O loop do exemplo acima realiza 2 itera\u00e7\u00f5es, ele \u00e9 um exemplo de um loop while com uma condi\u00e7\u00e3o. z = 7 y = 5 x = 0 while x < y and y < z : print ( f 'X eh menor que Y e Y eh menor que Z' ) x += 1 y += 1 NOTE QUE: O loop do exemplo acima realiza 2 itera\u00e7\u00f5es, ele \u00e9 um exemplo de um loop while com mais de uma condi\u00e7\u00e3o.","title":"While"},{"location":"Basic/Structs/loop.html#for-loop","text":"O loop For \u00e9 uma estrutura de repeti\u00e7\u00e3o bem interessante em Python, a sua vantagem em rela\u00e7\u00e3o ao loop while \u00e9 que n\u00e3o precisa da declara\u00e7\u00e3o de uma vari\u00e1vel de controle e sua sintaxe \u00e9 bastante simples e vers\u00e1til. inicio = 1 'O inicio \u00e9 incluido' final = 10 'O final n\u00e3o \u00e9 incluido' incremento = 5 'O incremento que vamos fazer para chegar no final' for x in range ( inicio , final , incremento ): print ( f ' { x } ' ) Podemos ver que a estrutura de repeti\u00e7\u00e3o for \u00e9 bem simples de entender, ela utiliza uma palavra in reservada e uma fun\u00e7\u00e3o range() , ou seja, semanticamente estamos dizendo \"para x no intervalo [ in\u00edcio , final - 1] pulando x de incremento em incremento\" fa\u00e7a alguma coisa. No caso do exemplo acima o la\u00e7o vai iterar duas vezes vamos esquematizar: for x in range ( 3 , 20 , 2 ): print ( f ' { x } ' ) Bom o c\u00f3digo acima demonstra a defini\u00e7\u00e3o de um loop for que s\u00f3 escreve no console os n\u00fameros \u00edmpares at\u00e9 19, a fun\u00e7\u00e3o range() pode gerar um tanto intervalo crescente quanto decrescente, vejamos um exemplo a seguir de um loop decrescente que imprime no console somente os n\u00fameros pares do intervalo: for x in range ( 20 , 3 , - 2 ): print ( f ' { x } ' ) NOTE QUE: Passamos o par\u00e2metro de incremento como negativo, caso contrario o intervalo n\u00e3o ser\u00e1 gerado e n\u00e3o vamos iterar no loop . Existe ainda uma ultima maneira de utilizar a fun\u00e7\u00e3o range() no loop for , passando somente um int como par\u00e2metro o intervalo gerado vai de 0 at\u00e9 uma unidade anterior ao par\u00e2metro com incremento unit\u00e1rio: for x in range ( 3 ): print ( f ' { x } ' )","title":"For Loop"},{"location":"Challenges/basic.html","text":"","title":"Desafios"},{"location":"Challenges/hard.html","text":"","title":"Desafios"},{"location":"Challenges/medium.html","text":"","title":"Desafios"},{"location":"Hard/intro.html","text":"","title":"Introdu\u00e7\u00e3o"},{"location":"Hard/POO/class.html","text":"","title":"Classes"},{"location":"Hard/POO/composicao.html","text":"","title":"Composi\u00e7\u00e3o"},{"location":"Hard/POO/convencoes.html","text":"","title":"Conven\u00e7\u00f5es"},{"location":"Hard/POO/heranca.html","text":"","title":"Heran\u00e7a"},{"location":"Hard/POO/object.html","text":"","title":"Objetos"},{"location":"Hard/POO/polimorfismo.html","text":"","title":"Polimorfismo"},{"location":"Init/config.html","text":"","title":"Ambiente de Desenvolvimento"},{"location":"Init/tools.html","text":"","title":"IDEs - Editores de Texto"},{"location":"Medium/intro.html","text":"","title":"Introdu\u00e7\u00e3o"},{"location":"Medium/CollectionsFunctions/filter.html","text":"","title":"Filter"},{"location":"Medium/CollectionsFunctions/groupBy.html","text":"","title":"GroupBy"},{"location":"Medium/CollectionsFunctions/map.html","text":"","title":"Map"},{"location":"Medium/CollectionsFunctions/reduce.html","text":"","title":"Reduce"},{"location":"Medium/IO/file.html","text":"","title":"Arquivos"},{"location":"Medium/Imports/import.html","text":"","title":"Imports"}]}